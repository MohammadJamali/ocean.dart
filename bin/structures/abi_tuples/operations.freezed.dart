// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'operations.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

Operations _$OperationsFromJson(Map<String, dynamic> json) {
  return _Operations.fromJson(json);
}

/// @nodoc
mixin _$Operations {
  @Uint8ListConverter()
  Uint8List get exchangeId => throw _privateConstructorUsedError;
  String get source => throw _privateConstructorUsedError;
  OperationType get operation => throw _privateConstructorUsedError;
  String get tokenIn => throw _privateConstructorUsedError;
  int get amountsIn => throw _privateConstructorUsedError;
  String get tokenOut => throw _privateConstructorUsedError;
  int get amountsOut => throw _privateConstructorUsedError;
  int get maxPrice => throw _privateConstructorUsedError;
  int get swapMarketFee => throw _privateConstructorUsedError;
  int get marketFeeAddress => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $OperationsCopyWith<Operations> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OperationsCopyWith<$Res> {
  factory $OperationsCopyWith(
          Operations value, $Res Function(Operations) then) =
      _$OperationsCopyWithImpl<$Res, Operations>;
  @useResult
  $Res call(
      {@Uint8ListConverter() Uint8List exchangeId,
      String source,
      OperationType operation,
      String tokenIn,
      int amountsIn,
      String tokenOut,
      int amountsOut,
      int maxPrice,
      int swapMarketFee,
      int marketFeeAddress});
}

/// @nodoc
class _$OperationsCopyWithImpl<$Res, $Val extends Operations>
    implements $OperationsCopyWith<$Res> {
  _$OperationsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? exchangeId = null,
    Object? source = null,
    Object? operation = null,
    Object? tokenIn = null,
    Object? amountsIn = null,
    Object? tokenOut = null,
    Object? amountsOut = null,
    Object? maxPrice = null,
    Object? swapMarketFee = null,
    Object? marketFeeAddress = null,
  }) {
    return _then(_value.copyWith(
      exchangeId: null == exchangeId
          ? _value.exchangeId
          : exchangeId // ignore: cast_nullable_to_non_nullable
              as Uint8List,
      source: null == source
          ? _value.source
          : source // ignore: cast_nullable_to_non_nullable
              as String,
      operation: null == operation
          ? _value.operation
          : operation // ignore: cast_nullable_to_non_nullable
              as OperationType,
      tokenIn: null == tokenIn
          ? _value.tokenIn
          : tokenIn // ignore: cast_nullable_to_non_nullable
              as String,
      amountsIn: null == amountsIn
          ? _value.amountsIn
          : amountsIn // ignore: cast_nullable_to_non_nullable
              as int,
      tokenOut: null == tokenOut
          ? _value.tokenOut
          : tokenOut // ignore: cast_nullable_to_non_nullable
              as String,
      amountsOut: null == amountsOut
          ? _value.amountsOut
          : amountsOut // ignore: cast_nullable_to_non_nullable
              as int,
      maxPrice: null == maxPrice
          ? _value.maxPrice
          : maxPrice // ignore: cast_nullable_to_non_nullable
              as int,
      swapMarketFee: null == swapMarketFee
          ? _value.swapMarketFee
          : swapMarketFee // ignore: cast_nullable_to_non_nullable
              as int,
      marketFeeAddress: null == marketFeeAddress
          ? _value.marketFeeAddress
          : marketFeeAddress // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$OperationsImplCopyWith<$Res>
    implements $OperationsCopyWith<$Res> {
  factory _$$OperationsImplCopyWith(
          _$OperationsImpl value, $Res Function(_$OperationsImpl) then) =
      __$$OperationsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@Uint8ListConverter() Uint8List exchangeId,
      String source,
      OperationType operation,
      String tokenIn,
      int amountsIn,
      String tokenOut,
      int amountsOut,
      int maxPrice,
      int swapMarketFee,
      int marketFeeAddress});
}

/// @nodoc
class __$$OperationsImplCopyWithImpl<$Res>
    extends _$OperationsCopyWithImpl<$Res, _$OperationsImpl>
    implements _$$OperationsImplCopyWith<$Res> {
  __$$OperationsImplCopyWithImpl(
      _$OperationsImpl _value, $Res Function(_$OperationsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? exchangeId = null,
    Object? source = null,
    Object? operation = null,
    Object? tokenIn = null,
    Object? amountsIn = null,
    Object? tokenOut = null,
    Object? amountsOut = null,
    Object? maxPrice = null,
    Object? swapMarketFee = null,
    Object? marketFeeAddress = null,
  }) {
    return _then(_$OperationsImpl(
      exchangeId: null == exchangeId
          ? _value.exchangeId
          : exchangeId // ignore: cast_nullable_to_non_nullable
              as Uint8List,
      source: null == source
          ? _value.source
          : source // ignore: cast_nullable_to_non_nullable
              as String,
      operation: null == operation
          ? _value.operation
          : operation // ignore: cast_nullable_to_non_nullable
              as OperationType,
      tokenIn: null == tokenIn
          ? _value.tokenIn
          : tokenIn // ignore: cast_nullable_to_non_nullable
              as String,
      amountsIn: null == amountsIn
          ? _value.amountsIn
          : amountsIn // ignore: cast_nullable_to_non_nullable
              as int,
      tokenOut: null == tokenOut
          ? _value.tokenOut
          : tokenOut // ignore: cast_nullable_to_non_nullable
              as String,
      amountsOut: null == amountsOut
          ? _value.amountsOut
          : amountsOut // ignore: cast_nullable_to_non_nullable
              as int,
      maxPrice: null == maxPrice
          ? _value.maxPrice
          : maxPrice // ignore: cast_nullable_to_non_nullable
              as int,
      swapMarketFee: null == swapMarketFee
          ? _value.swapMarketFee
          : swapMarketFee // ignore: cast_nullable_to_non_nullable
              as int,
      marketFeeAddress: null == marketFeeAddress
          ? _value.marketFeeAddress
          : marketFeeAddress // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$OperationsImpl implements _Operations {
  const _$OperationsImpl(
      {@Uint8ListConverter() required this.exchangeId,
      required this.source,
      required this.operation,
      required this.tokenIn,
      required this.amountsIn,
      required this.tokenOut,
      required this.amountsOut,
      required this.maxPrice,
      required this.swapMarketFee,
      required this.marketFeeAddress});

  factory _$OperationsImpl.fromJson(Map<String, dynamic> json) =>
      _$$OperationsImplFromJson(json);

  @override
  @Uint8ListConverter()
  final Uint8List exchangeId;
  @override
  final String source;
  @override
  final OperationType operation;
  @override
  final String tokenIn;
  @override
  final int amountsIn;
  @override
  final String tokenOut;
  @override
  final int amountsOut;
  @override
  final int maxPrice;
  @override
  final int swapMarketFee;
  @override
  final int marketFeeAddress;

  @override
  String toString() {
    return 'Operations(exchangeId: $exchangeId, source: $source, operation: $operation, tokenIn: $tokenIn, amountsIn: $amountsIn, tokenOut: $tokenOut, amountsOut: $amountsOut, maxPrice: $maxPrice, swapMarketFee: $swapMarketFee, marketFeeAddress: $marketFeeAddress)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OperationsImpl &&
            const DeepCollectionEquality()
                .equals(other.exchangeId, exchangeId) &&
            (identical(other.source, source) || other.source == source) &&
            (identical(other.operation, operation) ||
                other.operation == operation) &&
            (identical(other.tokenIn, tokenIn) || other.tokenIn == tokenIn) &&
            (identical(other.amountsIn, amountsIn) ||
                other.amountsIn == amountsIn) &&
            (identical(other.tokenOut, tokenOut) ||
                other.tokenOut == tokenOut) &&
            (identical(other.amountsOut, amountsOut) ||
                other.amountsOut == amountsOut) &&
            (identical(other.maxPrice, maxPrice) ||
                other.maxPrice == maxPrice) &&
            (identical(other.swapMarketFee, swapMarketFee) ||
                other.swapMarketFee == swapMarketFee) &&
            (identical(other.marketFeeAddress, marketFeeAddress) ||
                other.marketFeeAddress == marketFeeAddress));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(exchangeId),
      source,
      operation,
      tokenIn,
      amountsIn,
      tokenOut,
      amountsOut,
      maxPrice,
      swapMarketFee,
      marketFeeAddress);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$OperationsImplCopyWith<_$OperationsImpl> get copyWith =>
      __$$OperationsImplCopyWithImpl<_$OperationsImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$OperationsImplToJson(
      this,
    );
  }
}

abstract class _Operations implements Operations {
  const factory _Operations(
      {@Uint8ListConverter() required final Uint8List exchangeId,
      required final String source,
      required final OperationType operation,
      required final String tokenIn,
      required final int amountsIn,
      required final String tokenOut,
      required final int amountsOut,
      required final int maxPrice,
      required final int swapMarketFee,
      required final int marketFeeAddress}) = _$OperationsImpl;

  factory _Operations.fromJson(Map<String, dynamic> json) =
      _$OperationsImpl.fromJson;

  @override
  @Uint8ListConverter()
  Uint8List get exchangeId;
  @override
  String get source;
  @override
  OperationType get operation;
  @override
  String get tokenIn;
  @override
  int get amountsIn;
  @override
  String get tokenOut;
  @override
  int get amountsOut;
  @override
  int get maxPrice;
  @override
  int get swapMarketFee;
  @override
  int get marketFeeAddress;
  @override
  @JsonKey(ignore: true)
  _$$OperationsImplCopyWith<_$OperationsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
